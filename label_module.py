from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QDialog, QComboBox, QPushButton
)
from PyQt5.QtCore import pyqtSlot
from PyQt5.QtGui import QFont
from serialhander import SerialHandler


class DataTypeDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Data Type")
        
        self.data_types = {
            "Timestamp (ms)": 0,
            "X Acceleration (mG)": 0,
            "Y Acceleration (mG)": 0,
            "Z Acceleration (mG)": 0,
            "X Gyro (mdps)": 0,
            "Y Gyro (mdps)": 0,
            "Z Gyro (mdps)": 0,
            "Front Left Speed (mph)": 0,
            "Front Left Brake Temp (C)": 0,
            "Front Left Ambient Temperature (C)": 0,
            "Front Right Speed (mph)": 0,
            "Front Right Brake Temp (C)": 0,
            "Front Right Ambient Temperature (C)": 0,
            "Back Left Speed (mph)": 0,
            "Back Left Brake Temp (C)": 0,
            "Back Left Ambient Temperature (C)": 0,
            "Back Right Speed (mph)": 0,
            "Back Right Brake Temp (C)": 0,
            "Back Right Ambient Temperature (C)": 0,
            "Differential Speed (RPM)": 0,
            "DRS Toggle": 0,
            "Steering Angle (deg)": 0,
            "Throttle Input": 0,
            "Front Brake Pressure (BAR)": 0,
            "Rear Brake Pressure (BAR)": 0,
            "GPS Latitude (DD)": 0,
            "GPS Longitude (DD)": 0,
            "Battery Voltage (mV)": 0,
            "Current Draw (mA)": 0,
            "Front Right Shock Pot (mm)": 0,
            "Front Left Shock Pot (mm)": 0,
            "Back Right Shock Pot (mm)": 0,
            "Back Left Shock Pot (mm)": 0,
            "Lap Counter": 0,
            "Refresh Rate": 0
        }

        self.layout = QVBoxLayout(self)
        self.label = QLabel("Choose a data type:")
        self.layout.addWidget(self.label)

        self.data_type_combo = QComboBox(self)
        self.data_type_combo.addItems(self.data_types.keys())
        self.layout.addWidget(self.data_type_combo)

        self.ok_button = QPushButton("OK")
        self.ok_button.clicked.connect(self.accept)
        self.layout.addWidget(self.ok_button)

    def return_selected(self):
        selected_text = self.data_type_combo.currentText()
        return selected_text, self.data_types[selected_text]


class LabelModule(QWidget):
    def __init__(self, serialhandler: SerialHandler, data_type: str):
        super().__init__()
        self.serialhandler = serialhandler
        self.data_type = data_type

        self.setGeometry(200, 100, 400, 100)
        self.layout = QVBoxLayout(self)
        
        self.label = QLabel()
        self.label.setStyleSheet("font-size: 28px;")
        self.layout.addWidget(self.label)
        
        # Connect the label update to the serialhandler's signal
        self.serialhandler.data_changed.connect(self.update_label)

    @pyqtSlot(dict)
    def update_label(self, new_data: dict):
        """
        Whenever new data arrives from SerialHandler, 
        update this label with the latest value of data_type.
        """
        if self.data_type not in new_data or len(new_data[self.data_type]) == 0:
            # If data_type key is missing or empty, do nothing or show placeholder
            self.label.setText(f"{self.data_type}: N/A")
            return

        # Retrieve the last entry for the chosen data column
        latest_val = new_data[self.data_type][-1]
        # Format the label
        self.label.setText(f"{self.data_type}: {latest_val:.2f}")

    #
    # --- SAVE/LOAD METHODS ---
    #
    def get_info(self) -> dict:
        """
        Returns a dictionary describing the current state,
        so the dashboard can save/restore it.
        """
        return {
            'type': 'LabelModule',      # to identify the module type
            'data_type': self.data_type
            # If you also want position/size:
            # 'pos': (self.x(), self.y()),
            # 'size': (self.width(), self.height())
        }

    def set_info(self, info: dict):
        """
        Takes a state dictionary (like one generated by get_info)
        and applies it to this LabelModule, so it restores its state.
        """
        if 'data_type' in info:
            self.data_type = info['data_type']

        # If you also store geometry, you can restore it:
        # if 'pos' in info and len(info['pos']) == 2:
        #     self.move(info['pos'][0], info['pos'][1])
        # if 'size' in info and len(info['size']) == 2:
        #     self.resize(info['size'][0], info['size'][1])

        # Optionally trigger a label update if your data already exists
        self.update_label(self.serialhandler.data)
